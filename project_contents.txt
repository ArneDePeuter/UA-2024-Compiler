grammar MyGrammar;

// Parser rules
program : (expression ';')+ ;

expression : logicalExpression ;

logicalExpression
    : logicalExpression ('&&' | '||') comparisonExpression
    | comparisonExpression
    ;

comparisonExpression
    : comparisonExpression ( '>' | '<' | '==' | '>=' | '<=' | '!=' ) additiveExpression
    | additiveExpression
    ;

additiveExpression
    : additiveExpression ('+' | '-') multiplicativeExpression
    | multiplicativeExpression
    ;

multiplicativeExpression
    : multiplicativeExpression ('*' | '/' | '%') bitwiseExpression
    | bitwiseExpression
    ;

bitwiseExpression
    : bitwiseExpression ('&' | '|' | '^') shiftExpression
    | shiftExpression
    ;

shiftExpression
    : shiftExpression ('<<' | '>>') unaryExpression
    | unaryExpression
    ;

unaryExpression
    : ('+' | '-' | '!') unaryExpression
    | primary
    ;

primary
    : NUMBER
    | '(' expression ')'
    ;


// Lexer rules
NUMBER : [0-9]+ ;
PLUS : '+';
MINUS : '-';
MUL : '*';
DIV : '/';
MOD : '%';
GT : '>';
LT : '<';
EQ : '==';
GE : '>=';
LE : '<=';
NE : '!=';
AND : '&&';
OR : '||';
NOT : '!';
LSHIFT : '<<';
RSHIFT : '>>';
BITAND : '&';
BITOR : '|';
BITXOR : '^';
BITNOT : '~';

WS : [ \t\r\n]+ -> skip ;
# Generated from MyGrammar.g4 by ANTLR 4.13.1
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
    from typing import TextIO
else:
    from typing.io import TextIO


def serializedATN():
    return [
        4,0,25,117,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,
        2,6,7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,
        13,7,13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,
        19,2,20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,1,0,1,0,1,1,
        1,1,1,2,1,2,1,3,4,3,59,8,3,11,3,12,3,60,1,4,1,4,1,5,1,5,1,6,1,6,
        1,7,1,7,1,8,1,8,1,9,1,9,1,10,1,10,1,11,1,11,1,11,1,12,1,12,1,12,
        1,13,1,13,1,13,1,14,1,14,1,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,
        1,17,1,18,1,18,1,18,1,19,1,19,1,19,1,20,1,20,1,21,1,21,1,22,1,22,
        1,23,1,23,1,24,4,24,112,8,24,11,24,12,24,113,1,24,1,24,0,0,25,1,
        1,3,2,5,3,7,4,9,5,11,6,13,7,15,8,17,9,19,10,21,11,23,12,25,13,27,
        14,29,15,31,16,33,17,35,18,37,19,39,20,41,21,43,22,45,23,47,24,49,
        25,1,0,2,1,0,48,57,3,0,9,10,13,13,32,32,118,0,1,1,0,0,0,0,3,1,0,
        0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,0,0,11,1,0,0,0,0,13,1,0,0,
        0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,1,0,0,0,0,23,1,0,0,
        0,0,25,1,0,0,0,0,27,1,0,0,0,0,29,1,0,0,0,0,31,1,0,0,0,0,33,1,0,0,
        0,0,35,1,0,0,0,0,37,1,0,0,0,0,39,1,0,0,0,0,41,1,0,0,0,0,43,1,0,0,
        0,0,45,1,0,0,0,0,47,1,0,0,0,0,49,1,0,0,0,1,51,1,0,0,0,3,53,1,0,0,
        0,5,55,1,0,0,0,7,58,1,0,0,0,9,62,1,0,0,0,11,64,1,0,0,0,13,66,1,0,
        0,0,15,68,1,0,0,0,17,70,1,0,0,0,19,72,1,0,0,0,21,74,1,0,0,0,23,76,
        1,0,0,0,25,79,1,0,0,0,27,82,1,0,0,0,29,85,1,0,0,0,31,88,1,0,0,0,
        33,91,1,0,0,0,35,94,1,0,0,0,37,96,1,0,0,0,39,99,1,0,0,0,41,102,1,
        0,0,0,43,104,1,0,0,0,45,106,1,0,0,0,47,108,1,0,0,0,49,111,1,0,0,
        0,51,52,5,59,0,0,52,2,1,0,0,0,53,54,5,40,0,0,54,4,1,0,0,0,55,56,
        5,41,0,0,56,6,1,0,0,0,57,59,7,0,0,0,58,57,1,0,0,0,59,60,1,0,0,0,
        60,58,1,0,0,0,60,61,1,0,0,0,61,8,1,0,0,0,62,63,5,43,0,0,63,10,1,
        0,0,0,64,65,5,45,0,0,65,12,1,0,0,0,66,67,5,42,0,0,67,14,1,0,0,0,
        68,69,5,47,0,0,69,16,1,0,0,0,70,71,5,37,0,0,71,18,1,0,0,0,72,73,
        5,62,0,0,73,20,1,0,0,0,74,75,5,60,0,0,75,22,1,0,0,0,76,77,5,61,0,
        0,77,78,5,61,0,0,78,24,1,0,0,0,79,80,5,62,0,0,80,81,5,61,0,0,81,
        26,1,0,0,0,82,83,5,60,0,0,83,84,5,61,0,0,84,28,1,0,0,0,85,86,5,33,
        0,0,86,87,5,61,0,0,87,30,1,0,0,0,88,89,5,38,0,0,89,90,5,38,0,0,90,
        32,1,0,0,0,91,92,5,124,0,0,92,93,5,124,0,0,93,34,1,0,0,0,94,95,5,
        33,0,0,95,36,1,0,0,0,96,97,5,60,0,0,97,98,5,60,0,0,98,38,1,0,0,0,
        99,100,5,62,0,0,100,101,5,62,0,0,101,40,1,0,0,0,102,103,5,38,0,0,
        103,42,1,0,0,0,104,105,5,124,0,0,105,44,1,0,0,0,106,107,5,94,0,0,
        107,46,1,0,0,0,108,109,5,126,0,0,109,48,1,0,0,0,110,112,7,1,0,0,
        111,110,1,0,0,0,112,113,1,0,0,0,113,111,1,0,0,0,113,114,1,0,0,0,
        114,115,1,0,0,0,115,116,6,24,0,0,116,50,1,0,0,0,3,0,60,113,1,6,0,
        0
    ]

class MyGrammarLexer(Lexer):

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    T__0 = 1
    T__1 = 2
    T__2 = 3
    NUMBER = 4
    PLUS = 5
    MINUS = 6
    MUL = 7
    DIV = 8
    MOD = 9
    GT = 10
    LT = 11
    EQ = 12
    GE = 13
    LE = 14
    NE = 15
    AND = 16
    OR = 17
    NOT = 18
    LSHIFT = 19
    RSHIFT = 20
    BITAND = 21
    BITOR = 22
    BITXOR = 23
    BITNOT = 24
    WS = 25

    channelNames = [ u"DEFAULT_TOKEN_CHANNEL", u"HIDDEN" ]

    modeNames = [ "DEFAULT_MODE" ]

    literalNames = [ "<INVALID>",
            "';'", "'('", "')'", "'+'", "'-'", "'*'", "'/'", "'%'", "'>'", 
            "'<'", "'=='", "'>='", "'<='", "'!='", "'&&'", "'||'", "'!'", 
            "'<<'", "'>>'", "'&'", "'|'", "'^'", "'~'" ]

    symbolicNames = [ "<INVALID>",
            "NUMBER", "PLUS", "MINUS", "MUL", "DIV", "MOD", "GT", "LT", 
            "EQ", "GE", "LE", "NE", "AND", "OR", "NOT", "LSHIFT", "RSHIFT", 
            "BITAND", "BITOR", "BITXOR", "BITNOT", "WS" ]

    ruleNames = [ "T__0", "T__1", "T__2", "NUMBER", "PLUS", "MINUS", "MUL", 
                  "DIV", "MOD", "GT", "LT", "EQ", "GE", "LE", "NE", "AND", 
                  "OR", "NOT", "LSHIFT", "RSHIFT", "BITAND", "BITOR", "BITXOR", 
                  "BITNOT", "WS" ]

    grammarFileName = "MyGrammar.g4"

    def __init__(self, input=None, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = LexerATNSimulator(self, self.atn, self.decisionsToDFA, PredictionContextCache())
        self._actions = None
        self._predicates = None


# Generated from MyGrammar.g4 by ANTLR 4.13.1
from antlr4 import *
if "." in __name__:
    from .MyGrammarParser import MyGrammarParser
else:
    from MyGrammarParser import MyGrammarParser

# This class defines a complete listener for a parse tree produced by MyGrammarParser.
class MyGrammarListener(ParseTreeListener):

    # Enter a parse tree produced by MyGrammarParser#program.
    def enterProgram(self, ctx:MyGrammarParser.ProgramContext):
        pass

    # Exit a parse tree produced by MyGrammarParser#program.
    def exitProgram(self, ctx:MyGrammarParser.ProgramContext):
        pass


    # Enter a parse tree produced by MyGrammarParser#expression.
    def enterExpression(self, ctx:MyGrammarParser.ExpressionContext):
        pass

    # Exit a parse tree produced by MyGrammarParser#expression.
    def exitExpression(self, ctx:MyGrammarParser.ExpressionContext):
        pass


    # Enter a parse tree produced by MyGrammarParser#logicalExpression.
    def enterLogicalExpression(self, ctx:MyGrammarParser.LogicalExpressionContext):
        pass

    # Exit a parse tree produced by MyGrammarParser#logicalExpression.
    def exitLogicalExpression(self, ctx:MyGrammarParser.LogicalExpressionContext):
        pass


    # Enter a parse tree produced by MyGrammarParser#comparisonExpression.
    def enterComparisonExpression(self, ctx:MyGrammarParser.ComparisonExpressionContext):
        pass

    # Exit a parse tree produced by MyGrammarParser#comparisonExpression.
    def exitComparisonExpression(self, ctx:MyGrammarParser.ComparisonExpressionContext):
        pass


    # Enter a parse tree produced by MyGrammarParser#additiveExpression.
    def enterAdditiveExpression(self, ctx:MyGrammarParser.AdditiveExpressionContext):
        pass

    # Exit a parse tree produced by MyGrammarParser#additiveExpression.
    def exitAdditiveExpression(self, ctx:MyGrammarParser.AdditiveExpressionContext):
        pass


    # Enter a parse tree produced by MyGrammarParser#multiplicativeExpression.
    def enterMultiplicativeExpression(self, ctx:MyGrammarParser.MultiplicativeExpressionContext):
        pass

    # Exit a parse tree produced by MyGrammarParser#multiplicativeExpression.
    def exitMultiplicativeExpression(self, ctx:MyGrammarParser.MultiplicativeExpressionContext):
        pass


    # Enter a parse tree produced by MyGrammarParser#bitwiseExpression.
    def enterBitwiseExpression(self, ctx:MyGrammarParser.BitwiseExpressionContext):
        pass

    # Exit a parse tree produced by MyGrammarParser#bitwiseExpression.
    def exitBitwiseExpression(self, ctx:MyGrammarParser.BitwiseExpressionContext):
        pass


    # Enter a parse tree produced by MyGrammarParser#shiftExpression.
    def enterShiftExpression(self, ctx:MyGrammarParser.ShiftExpressionContext):
        pass

    # Exit a parse tree produced by MyGrammarParser#shiftExpression.
    def exitShiftExpression(self, ctx:MyGrammarParser.ShiftExpressionContext):
        pass


    # Enter a parse tree produced by MyGrammarParser#unaryExpression.
    def enterUnaryExpression(self, ctx:MyGrammarParser.UnaryExpressionContext):
        pass

    # Exit a parse tree produced by MyGrammarParser#unaryExpression.
    def exitUnaryExpression(self, ctx:MyGrammarParser.UnaryExpressionContext):
        pass


    # Enter a parse tree produced by MyGrammarParser#primary.
    def enterPrimary(self, ctx:MyGrammarParser.PrimaryContext):
        pass

    # Exit a parse tree produced by MyGrammarParser#primary.
    def exitPrimary(self, ctx:MyGrammarParser.PrimaryContext):
        pass



del MyGrammarParser# Generated from MyGrammar.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,25,108,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,1,0,1,0,1,0,4,0,24,8,0,11,0,12,0,25,1,
        1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,5,2,36,8,2,10,2,12,2,39,9,2,1,3,1,
        3,1,3,1,3,1,3,1,3,5,3,47,8,3,10,3,12,3,50,9,3,1,4,1,4,1,4,1,4,1,
        4,1,4,5,4,58,8,4,10,4,12,4,61,9,4,1,5,1,5,1,5,1,5,1,5,1,5,5,5,69,
        8,5,10,5,12,5,72,9,5,1,6,1,6,1,6,1,6,1,6,1,6,5,6,80,8,6,10,6,12,
        6,83,9,6,1,7,1,7,1,7,1,7,1,7,1,7,5,7,91,8,7,10,7,12,7,94,9,7,1,8,
        1,8,1,8,3,8,99,8,8,1,9,1,9,1,9,1,9,1,9,3,9,106,8,9,1,9,0,6,4,6,8,
        10,12,14,10,0,2,4,6,8,10,12,14,16,18,0,7,1,0,16,17,1,0,10,15,1,0,
        5,6,1,0,7,9,1,0,21,23,1,0,19,20,2,0,5,6,18,18,106,0,23,1,0,0,0,2,
        27,1,0,0,0,4,29,1,0,0,0,6,40,1,0,0,0,8,51,1,0,0,0,10,62,1,0,0,0,
        12,73,1,0,0,0,14,84,1,0,0,0,16,98,1,0,0,0,18,105,1,0,0,0,20,21,3,
        2,1,0,21,22,5,1,0,0,22,24,1,0,0,0,23,20,1,0,0,0,24,25,1,0,0,0,25,
        23,1,0,0,0,25,26,1,0,0,0,26,1,1,0,0,0,27,28,3,4,2,0,28,3,1,0,0,0,
        29,30,6,2,-1,0,30,31,3,6,3,0,31,37,1,0,0,0,32,33,10,2,0,0,33,34,
        7,0,0,0,34,36,3,6,3,0,35,32,1,0,0,0,36,39,1,0,0,0,37,35,1,0,0,0,
        37,38,1,0,0,0,38,5,1,0,0,0,39,37,1,0,0,0,40,41,6,3,-1,0,41,42,3,
        8,4,0,42,48,1,0,0,0,43,44,10,2,0,0,44,45,7,1,0,0,45,47,3,8,4,0,46,
        43,1,0,0,0,47,50,1,0,0,0,48,46,1,0,0,0,48,49,1,0,0,0,49,7,1,0,0,
        0,50,48,1,0,0,0,51,52,6,4,-1,0,52,53,3,10,5,0,53,59,1,0,0,0,54,55,
        10,2,0,0,55,56,7,2,0,0,56,58,3,10,5,0,57,54,1,0,0,0,58,61,1,0,0,
        0,59,57,1,0,0,0,59,60,1,0,0,0,60,9,1,0,0,0,61,59,1,0,0,0,62,63,6,
        5,-1,0,63,64,3,12,6,0,64,70,1,0,0,0,65,66,10,2,0,0,66,67,7,3,0,0,
        67,69,3,12,6,0,68,65,1,0,0,0,69,72,1,0,0,0,70,68,1,0,0,0,70,71,1,
        0,0,0,71,11,1,0,0,0,72,70,1,0,0,0,73,74,6,6,-1,0,74,75,3,14,7,0,
        75,81,1,0,0,0,76,77,10,2,0,0,77,78,7,4,0,0,78,80,3,14,7,0,79,76,
        1,0,0,0,80,83,1,0,0,0,81,79,1,0,0,0,81,82,1,0,0,0,82,13,1,0,0,0,
        83,81,1,0,0,0,84,85,6,7,-1,0,85,86,3,16,8,0,86,92,1,0,0,0,87,88,
        10,2,0,0,88,89,7,5,0,0,89,91,3,16,8,0,90,87,1,0,0,0,91,94,1,0,0,
        0,92,90,1,0,0,0,92,93,1,0,0,0,93,15,1,0,0,0,94,92,1,0,0,0,95,96,
        7,6,0,0,96,99,3,16,8,0,97,99,3,18,9,0,98,95,1,0,0,0,98,97,1,0,0,
        0,99,17,1,0,0,0,100,106,5,4,0,0,101,102,5,2,0,0,102,103,3,2,1,0,
        103,104,5,3,0,0,104,106,1,0,0,0,105,100,1,0,0,0,105,101,1,0,0,0,
        106,19,1,0,0,0,9,25,37,48,59,70,81,92,98,105
    ]

class MyGrammarParser ( Parser ):

    grammarFileName = "MyGrammar.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "'('", "')'", "<INVALID>", "'+'", 
                     "'-'", "'*'", "'/'", "'%'", "'>'", "'<'", "'=='", "'>='", 
                     "'<='", "'!='", "'&&'", "'||'", "'!'", "'<<'", "'>>'", 
                     "'&'", "'|'", "'^'", "'~'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "NUMBER", "PLUS", "MINUS", "MUL", "DIV", "MOD", "GT", 
                      "LT", "EQ", "GE", "LE", "NE", "AND", "OR", "NOT", 
                      "LSHIFT", "RSHIFT", "BITAND", "BITOR", "BITXOR", "BITNOT", 
                      "WS" ]

    RULE_program = 0
    RULE_expression = 1
    RULE_logicalExpression = 2
    RULE_comparisonExpression = 3
    RULE_additiveExpression = 4
    RULE_multiplicativeExpression = 5
    RULE_bitwiseExpression = 6
    RULE_shiftExpression = 7
    RULE_unaryExpression = 8
    RULE_primary = 9

    ruleNames =  [ "program", "expression", "logicalExpression", "comparisonExpression", 
                   "additiveExpression", "multiplicativeExpression", "bitwiseExpression", 
                   "shiftExpression", "unaryExpression", "primary" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    NUMBER=4
    PLUS=5
    MINUS=6
    MUL=7
    DIV=8
    MOD=9
    GT=10
    LT=11
    EQ=12
    GE=13
    LE=14
    NE=15
    AND=16
    OR=17
    NOT=18
    LSHIFT=19
    RSHIFT=20
    BITAND=21
    BITOR=22
    BITXOR=23
    BITNOT=24
    WS=25

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MyGrammarParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(MyGrammarParser.ExpressionContext,i)


        def getRuleIndex(self):
            return MyGrammarParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = MyGrammarParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 23 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 20
                self.expression()
                self.state = 21
                self.match(MyGrammarParser.T__0)
                self.state = 25 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 262260) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.LogicalExpressionContext,0)


        def getRuleIndex(self):
            return MyGrammarParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = MyGrammarParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 27
            self.logicalExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparisonExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.ComparisonExpressionContext,0)


        def logicalExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.LogicalExpressionContext,0)


        def AND(self):
            return self.getToken(MyGrammarParser.AND, 0)

        def OR(self):
            return self.getToken(MyGrammarParser.OR, 0)

        def getRuleIndex(self):
            return MyGrammarParser.RULE_logicalExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalExpression" ):
                listener.enterLogicalExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalExpression" ):
                listener.exitLogicalExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalExpression" ):
                return visitor.visitLogicalExpression(self)
            else:
                return visitor.visitChildren(self)



    def logicalExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MyGrammarParser.LogicalExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 4
        self.enterRecursionRule(localctx, 4, self.RULE_logicalExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 30
            self.comparisonExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 37
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MyGrammarParser.LogicalExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_logicalExpression)
                    self.state = 32
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 33
                    _la = self._input.LA(1)
                    if not(_la==16 or _la==17):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 34
                    self.comparisonExpression(0) 
                self.state = 39
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ComparisonExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def additiveExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.AdditiveExpressionContext,0)


        def comparisonExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.ComparisonExpressionContext,0)


        def GT(self):
            return self.getToken(MyGrammarParser.GT, 0)

        def LT(self):
            return self.getToken(MyGrammarParser.LT, 0)

        def EQ(self):
            return self.getToken(MyGrammarParser.EQ, 0)

        def GE(self):
            return self.getToken(MyGrammarParser.GE, 0)

        def LE(self):
            return self.getToken(MyGrammarParser.LE, 0)

        def NE(self):
            return self.getToken(MyGrammarParser.NE, 0)

        def getRuleIndex(self):
            return MyGrammarParser.RULE_comparisonExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonExpression" ):
                listener.enterComparisonExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonExpression" ):
                listener.exitComparisonExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonExpression" ):
                return visitor.visitComparisonExpression(self)
            else:
                return visitor.visitChildren(self)



    def comparisonExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MyGrammarParser.ComparisonExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 6
        self.enterRecursionRule(localctx, 6, self.RULE_comparisonExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 41
            self.additiveExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 48
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MyGrammarParser.ComparisonExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_comparisonExpression)
                    self.state = 43
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 44
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 64512) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 45
                    self.additiveExpression(0) 
                self.state = 50
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AdditiveExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multiplicativeExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.MultiplicativeExpressionContext,0)


        def additiveExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.AdditiveExpressionContext,0)


        def PLUS(self):
            return self.getToken(MyGrammarParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(MyGrammarParser.MINUS, 0)

        def getRuleIndex(self):
            return MyGrammarParser.RULE_additiveExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveExpression" ):
                listener.enterAdditiveExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveExpression" ):
                listener.exitAdditiveExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveExpression" ):
                return visitor.visitAdditiveExpression(self)
            else:
                return visitor.visitChildren(self)



    def additiveExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MyGrammarParser.AdditiveExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 8
        self.enterRecursionRule(localctx, 8, self.RULE_additiveExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 52
            self.multiplicativeExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 59
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MyGrammarParser.AdditiveExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_additiveExpression)
                    self.state = 54
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 55
                    _la = self._input.LA(1)
                    if not(_la==5 or _la==6):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 56
                    self.multiplicativeExpression(0) 
                self.state = 61
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class MultiplicativeExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bitwiseExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.BitwiseExpressionContext,0)


        def multiplicativeExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.MultiplicativeExpressionContext,0)


        def MUL(self):
            return self.getToken(MyGrammarParser.MUL, 0)

        def DIV(self):
            return self.getToken(MyGrammarParser.DIV, 0)

        def MOD(self):
            return self.getToken(MyGrammarParser.MOD, 0)

        def getRuleIndex(self):
            return MyGrammarParser.RULE_multiplicativeExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeExpression" ):
                listener.enterMultiplicativeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeExpression" ):
                listener.exitMultiplicativeExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeExpression" ):
                return visitor.visitMultiplicativeExpression(self)
            else:
                return visitor.visitChildren(self)



    def multiplicativeExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MyGrammarParser.MultiplicativeExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 10
        self.enterRecursionRule(localctx, 10, self.RULE_multiplicativeExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            self.bitwiseExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 70
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MyGrammarParser.MultiplicativeExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_multiplicativeExpression)
                    self.state = 65
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 66
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 896) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 67
                    self.bitwiseExpression(0) 
                self.state = 72
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class BitwiseExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shiftExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.ShiftExpressionContext,0)


        def bitwiseExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.BitwiseExpressionContext,0)


        def BITAND(self):
            return self.getToken(MyGrammarParser.BITAND, 0)

        def BITOR(self):
            return self.getToken(MyGrammarParser.BITOR, 0)

        def BITXOR(self):
            return self.getToken(MyGrammarParser.BITXOR, 0)

        def getRuleIndex(self):
            return MyGrammarParser.RULE_bitwiseExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitwiseExpression" ):
                listener.enterBitwiseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitwiseExpression" ):
                listener.exitBitwiseExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitwiseExpression" ):
                return visitor.visitBitwiseExpression(self)
            else:
                return visitor.visitChildren(self)



    def bitwiseExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MyGrammarParser.BitwiseExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 12
        self.enterRecursionRule(localctx, 12, self.RULE_bitwiseExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self.shiftExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 81
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MyGrammarParser.BitwiseExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_bitwiseExpression)
                    self.state = 76
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 77
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 14680064) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 78
                    self.shiftExpression(0) 
                self.state = 83
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ShiftExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unaryExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.UnaryExpressionContext,0)


        def shiftExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.ShiftExpressionContext,0)


        def LSHIFT(self):
            return self.getToken(MyGrammarParser.LSHIFT, 0)

        def RSHIFT(self):
            return self.getToken(MyGrammarParser.RSHIFT, 0)

        def getRuleIndex(self):
            return MyGrammarParser.RULE_shiftExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShiftExpression" ):
                listener.enterShiftExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShiftExpression" ):
                listener.exitShiftExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShiftExpression" ):
                return visitor.visitShiftExpression(self)
            else:
                return visitor.visitChildren(self)



    def shiftExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = MyGrammarParser.ShiftExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 14
        self.enterRecursionRule(localctx, 14, self.RULE_shiftExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 85
            self.unaryExpression()
            self._ctx.stop = self._input.LT(-1)
            self.state = 92
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = MyGrammarParser.ShiftExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_shiftExpression)
                    self.state = 87
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 88
                    _la = self._input.LA(1)
                    if not(_la==19 or _la==20):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 89
                    self.unaryExpression() 
                self.state = 94
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class UnaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unaryExpression(self):
            return self.getTypedRuleContext(MyGrammarParser.UnaryExpressionContext,0)


        def PLUS(self):
            return self.getToken(MyGrammarParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(MyGrammarParser.MINUS, 0)

        def NOT(self):
            return self.getToken(MyGrammarParser.NOT, 0)

        def primary(self):
            return self.getTypedRuleContext(MyGrammarParser.PrimaryContext,0)


        def getRuleIndex(self):
            return MyGrammarParser.RULE_unaryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryExpression" ):
                listener.enterUnaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryExpression" ):
                listener.exitUnaryExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryExpression" ):
                return visitor.visitUnaryExpression(self)
            else:
                return visitor.visitChildren(self)




    def unaryExpression(self):

        localctx = MyGrammarParser.UnaryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_unaryExpression)
        self._la = 0 # Token type
        try:
            self.state = 98
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5, 6, 18]:
                self.enterOuterAlt(localctx, 1)
                self.state = 95
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 262240) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 96
                self.unaryExpression()
                pass
            elif token in [2, 4]:
                self.enterOuterAlt(localctx, 2)
                self.state = 97
                self.primary()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(MyGrammarParser.NUMBER, 0)

        def expression(self):
            return self.getTypedRuleContext(MyGrammarParser.ExpressionContext,0)


        def getRuleIndex(self):
            return MyGrammarParser.RULE_primary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimary" ):
                listener.enterPrimary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimary" ):
                listener.exitPrimary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimary" ):
                return visitor.visitPrimary(self)
            else:
                return visitor.visitChildren(self)




    def primary(self):

        localctx = MyGrammarParser.PrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_primary)
        try:
            self.state = 105
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4]:
                self.enterOuterAlt(localctx, 1)
                self.state = 100
                self.match(MyGrammarParser.NUMBER)
                pass
            elif token in [2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 101
                self.match(MyGrammarParser.T__1)
                self.state = 102
                self.expression()
                self.state = 103
                self.match(MyGrammarParser.T__2)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[2] = self.logicalExpression_sempred
        self._predicates[3] = self.comparisonExpression_sempred
        self._predicates[4] = self.additiveExpression_sempred
        self._predicates[5] = self.multiplicativeExpression_sempred
        self._predicates[6] = self.bitwiseExpression_sempred
        self._predicates[7] = self.shiftExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def logicalExpression_sempred(self, localctx:LogicalExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def comparisonExpression_sempred(self, localctx:ComparisonExpressionContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 2)
         

    def additiveExpression_sempred(self, localctx:AdditiveExpressionContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         

    def multiplicativeExpression_sempred(self, localctx:MultiplicativeExpressionContext, predIndex:int):
            if predIndex == 3:
                return self.precpred(self._ctx, 2)
         

    def bitwiseExpression_sempred(self, localctx:BitwiseExpressionContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 2)
         

    def shiftExpression_sempred(self, localctx:ShiftExpressionContext, predIndex:int):
            if predIndex == 5:
                return self.precpred(self._ctx, 2)
         




# Generated from MyGrammar.g4 by ANTLR 4.13.1
from antlr4 import *
if "." in __name__:
    from .MyGrammarParser import MyGrammarParser
else:
    from MyGrammarParser import MyGrammarParser

# This class defines a complete generic visitor for a parse tree produced by MyGrammarParser.

class MyGrammarVisitor(ParseTreeVisitor):

    # Visit a parse tree produced by MyGrammarParser#program.
    def visitProgram(self, ctx:MyGrammarParser.ProgramContext):
        return self.visitChildren(ctx)


    # Visit a parse tree produced by MyGrammarParser#expression.
    def visitExpression(self, ctx:MyGrammarParser.ExpressionContext):
        return self.visitChildren(ctx)


    # Visit a parse tree produced by MyGrammarParser#logicalExpression.
    def visitLogicalExpression(self, ctx:MyGrammarParser.LogicalExpressionContext):
        return self.visitChildren(ctx)


    # Visit a parse tree produced by MyGrammarParser#comparisonExpression.
    def visitComparisonExpression(self, ctx:MyGrammarParser.ComparisonExpressionContext):
        return self.visitChildren(ctx)


    # Visit a parse tree produced by MyGrammarParser#additiveExpression.
    def visitAdditiveExpression(self, ctx:MyGrammarParser.AdditiveExpressionContext):
        return self.visitChildren(ctx)


    # Visit a parse tree produced by MyGrammarParser#multiplicativeExpression.
    def visitMultiplicativeExpression(self, ctx:MyGrammarParser.MultiplicativeExpressionContext):
        return self.visitChildren(ctx)


    # Visit a parse tree produced by MyGrammarParser#bitwiseExpression.
    def visitBitwiseExpression(self, ctx:MyGrammarParser.BitwiseExpressionContext):
        return self.visitChildren(ctx)


    # Visit a parse tree produced by MyGrammarParser#shiftExpression.
    def visitShiftExpression(self, ctx:MyGrammarParser.ShiftExpressionContext):
        return self.visitChildren(ctx)


    # Visit a parse tree produced by MyGrammarParser#unaryExpression.
    def visitUnaryExpression(self, ctx:MyGrammarParser.UnaryExpressionContext):
        return self.visitChildren(ctx)


    # Visit a parse tree produced by MyGrammarParser#primary.
    def visitPrimary(self, ctx:MyGrammarParser.PrimaryContext):
        return self.visitChildren(ctx)



del MyGrammarParserimport antlr4
from src.antlr_files.MyGrammarLexer import MyGrammarLexer
from src.antlr_files.MyGrammarParser import MyGrammarParser
from src.parser.visitor.concretevisitor import ConcreteVisitor as CustomASTVisitor  # This will be your custom visitor for AST construction
from src.parser.visitor.dotvisitor import DotVisitor
import argparse
import subprocess

def print_ast(node, level=0):
    if node is None:
        return
    # Indent to show tree structure
    indent = ' ' * (level * 2)
    print(f"{indent}{type(node).__name__}: {node}")
    # If the node has children or attributes that are AST nodes, print them as well
    if hasattr(node, 'left'):
        print_ast(node.left, level + 1)
    if hasattr(node, 'right'):
        print_ast(node.right, level + 1)
    if hasattr(node, 'operand'):  # For unary operations
        print_ast(node.operand, level + 1)

def main():
    parser = argparse.ArgumentParser(description='Process some integers.')
    parser.add_argument('--input', dest="filename", help='the input file to compile')
    parser.add_argument('--render_ast', dest="render_ast", help='the input file to compile')
    parser.add_argument('--render_symb', dest="render_symb", help='the input file to compile')
    parser.add_argument('--target_llvm', dest="target_llvm", help='the input file to compile')
    parser.add_argument('--target_mips', dest="target_mips", help='the input file to compile')

    args = parser.parse_args()
    if not args.filename:
        raise RuntimeError("You didn't specify a file to compile")

    with open(args.filename, 'r') as file:
        input_stream = antlr4.InputStream(file.read())

    lexer = MyGrammarLexer(input_stream)
    token_stream = antlr4.CommonTokenStream(lexer)
    parser = MyGrammarParser(token_stream)
    
    #tree = parser.expression() # Only one expression
    tree = parser.program() # The complete program
    
    visitor = CustomASTVisitor()
    ast = visitor.visit(tree)

    if ast:
        print("AST generated:")
        print_ast(ast)
        dot_visitor = DotVisitor()
        dot_visitor.gen_binary_dot(ast, "root")
        dotfile = "temp/ast_proj1"
        dot_visitor.output(dotfile+".dot")

    else:
        print("No AST generated.")

if __name__ == "__main__":
    main()
from abc import abstractmethod, ABC


class AST(ABC):
    pass

from .ast import AST
from enum import Enum


class Expression(AST):
    pass


class INT(AST):
    def __init__(self, value: int) -> None:
        self.value = value


class BinaryOperation(Expression):
    def __init__(self, left: Expression, right: Expression) -> None:
        self.left = left
        self.right = right


class BinaryArithmetic(BinaryOperation):
    class Operator(Enum):
        PLUS = "+"
        MINUS = "-"
        MUL = "*"
        DIV = "/"
        MOD = "%"

    def __init__(self, left: Expression, right: Expression, operator: Operator) -> None:
        super().__init__(left, right)
        self.operator = operator


class BinaryBitwiseArithmetic(BinaryOperation):
    class Operator(Enum):
        AND = "&"
        OR = "|"
        XOR = "^"

    def __init__(self, left: Expression, right: Expression, operator: Operator) -> None:
        super().__init__(left, right)
        self.operator = operator


class BinaryLogicalOperation(BinaryOperation):
    class Operator(Enum):
        AND = "&&"
        OR = "||"

    def __init__(self, left: Expression, right: Expression, operator: Operator) -> None:
        super().__init__(left, right)
        self.operator = operator


class ComparisonOperation(BinaryOperation):
    class Operator(Enum):
        GT = ">"
        LT = "<"
        GTE = ">="
        LTE = "<="
        EQ = "=="
        NEQ = "!="

    def __init__(self, left: Expression, right: Expression, operator: Operator) -> None:
        super().__init__(left, right)
        self.operator = operator


class UnaryExpression(Expression):
    class Operator(Enum):
        POSITIVE = "+"
        NEGATIVE = "-"
        ONESCOMPLEMENT = "~"
        LOGICALNEGATION = "!"

    def __init__(self, value: Expression, operator: Operator) -> None:
        self.value = value
        self.operator = operator

class BitwiseExpression(BinaryOperation):
    class Operator(Enum):
        BITAND = "&"
        BITOR = "|"
        BITXOR = "^"
        BITNOT = "~"

    def __init__(self, left, op, right):
        self.left = left  # The left operand
        self.op = op      # The operator ('&', '|', '^')
        self.right = right  # The right operand

class ShiftExpression(Expression):
    class Operator(Enum):
        LEFT = "<<"
        RIGHT = ">>"

    def __init__(self, value: Expression, operator: Operator, shamt: int) -> None:
        self.value = value
        self.operator = operator
        self.shamt = shamtfrom antlr4 import *
from src.antlr_files.MyGrammarLexer import MyGrammarLexer
from src.antlr_files.MyGrammarParser import MyGrammarParser
from src.antlr_files.MyGrammarVisitor import MyGrammarVisitor
from ..ast.expression import *

class ConcreteVisitor(MyGrammarVisitor):
    def visitAdditiveExpression(self, ctx:MyGrammarParser.AdditiveExpressionContext):
        if ctx.getChildCount() == 1:
            return self.visit(ctx.getChild(0))
        left = self.visit(ctx.getChild(0))
        right = self.visit(ctx.getChild(2))
        op = ctx.getChild(1)
        return BinaryArithmetic(left, right, op)

    def visitMultiplicativeExpression(self, ctx:MyGrammarParser.MultiplicativeExpressionContext):
        if ctx.getChildCount() == 1:
            return self.visit(ctx.getChild(0))
        left = self.visit(ctx.getChild(0))
        right = self.visit(ctx.getChild(2))
        op = ctx.getChild(1)
        return BinaryArithmetic(left, right, op)
    def visitLogicalExpression(self, ctx:MyGrammarParser.LogicalExpressionContext):
        if ctx.getChildCount() == 1:
            return self.visit(ctx.getChild(0))
        left = self.visit(ctx.getChild(0))
        right = self.visit(ctx.getChild(2))
        op = ctx.getChild(1)
        return BinaryLogicalOperation(left, right, op)

    def visitComparisonExpression(self, ctx:MyGrammarParser.ComparisonExpressionContext):
        if ctx.getChildCount() == 1:
            return self.visit(ctx.getChild(0))
        left = self.visit(ctx.getChild(0))
        right = self.visit(ctx.getChild(2))
        op = ctx.getChild(1)
        return ComparisonOperation(left, right, op)

    def visitUnaryExpression(self, ctx:MyGrammarParser.UnaryExpressionContext):
        # If the unary expression is just a primary expression
        if ctx.primary():
            return self.visit(ctx.primary())
        # If the unary expression contains another unary expression
        operator = ctx.getChild(0).getText()  # Get the text of the unary operator
        expr = self.visit(ctx.unaryExpression())  # Recursively visit the unary expression
        # Translate string operator to the corresponding Enum
        if operator == '+':
            op = UnaryExpression.Operator.POSITIVE
        elif operator == '-':
            op = UnaryExpression.Operator.NEGATIVE
        elif operator == '!':
            op = UnaryExpression.Operator.LOGICALNEGATION
        else:
            op = UnaryExpression.Operator.ONESCOMPLEMENT
        return UnaryExpression(expr, op)


    def visitBitwiseExpression(self, ctx:MyGrammarParser.BitwiseExpressionContext):
        if ctx.getChildCount() == 1:
            return self.visit(ctx.getChild(0))
        left = self.visit(ctx.getChild(0))
        right = self.visit(ctx.getChild(2))
        op = ctx.getChild(1)
        return BitwiseExpression(left, right, op)

    # TODO: handle ShiftExpression properly
    def visitShiftExpression(self, ctx:MyGrammarParser.ShiftExpressionContext):
        if ctx.getChildCount() == 1:
            # If there's no shift operation (i.e., it's just a unary expression)
            return self.visit(ctx.unaryExpression())
        else:
            # If there is a shift operation
            left = self.visit(ctx.shiftExpression())  # Visit the left-hand side (which is another shiftExpression)
            right = self.visit(ctx.unaryExpression())  # Visit the right-hand side (which should be an unaryExpression, not primary)
            # Determine the operation based on the context's text
            op = ctx.getChild(1).getText()  # Get the operator ('<<' or '>>')
            # Depending on your AST node structure, you may need to create a new ShiftExpression node here.
            # Assuming you have a corresponding AST class and enum for shift operations:
            if op == '<<':
                operation = ShiftExpression.Operator.LEFT
            else:
                operation = ShiftExpression.Operator.RIGHT
            # Assuming your ShiftExpression class takes the left and right operands and the operation
            return ShiftExpression(left, operation, right)  # Note: Adjust according to your actual AST class structure


    def visitPrimary(self, ctx:MyGrammarParser.PrimaryContext):
        if ctx.NUMBER() is not None:
            return INT(int(ctx.NUMBER().getText()))
        elif ctx.expression() is not None:
            return self.visit(ctx.expression())
from typing import Any

from .visitor import Visitor
from ..ast import expression as EXPR


class DotVisitor(Visitor):
    def __init__(self):
        super().__init__()
        self.total = ""

    def output(self, filename: str):
        with open(filename, "w") as file:
            file.write("digraph ExpressionGraph {\n")
            file.write(self.total)
            file.write("}\n")

    def gen_binary_dot(self, me: EXPR.BinaryOperation, operator: str) -> None:
        node_name = str(id(me))
        self.total += f"{node_name} [label=\"{me.operator}\"];\n"
        left_node_name = str(id(me.left))
        right_node_name = str(id(me.right))
        self.total += f"{node_name} -> {left_node_name};\n"
        self.total += f"{node_name} -> {right_node_name};\n"
        self.visit_ast(me.left)
        self.visit_ast(me.right)

    def visit_binary_arithmetic(self, expr: EXPR.BinaryArithmetic) -> Any:
        self.gen_binary_dot(expr, expr.operator)

    def visit_binary_bitwise_arithmetic(self, expr: EXPR.BinaryBitwiseArithmetic) -> Any:
        self.gen_binary_dot(expr, expr.operator)

    def visit_binary_logical_operation(self, expr: EXPR.BinaryLogicalOperation) -> Any:
        self.gen_binary_dot(expr, expr.operator)

    def visit_comparison_operation(self, expr: EXPR.ComparisonOperation) -> Any:
        self.gen_binary_dot(expr, expr.operator)

    def visit_unary_expression(self, expr: EXPR.UnaryExpression) -> Any:
        node_name = id(expr)
        self.total += f"{node_name} [label=\"{expr.operator}\"];\n"
        child_name = id(expr.value)
        self.total += f"{node_name} -> {child_name};\n"
        self.visit_ast(expr.value)

    def visit_shift_expression(self, expr: EXPR.ShiftExpression) -> Any:
        node_name = id(expr)
        self.total += f"{node_name} [label=\"{expr.operator}{expr.shamt}\"];\n"
        child_name = id(expr.value)
        self.total += f"{node_name} -> {child_name};\n"
        self.visit_ast(expr.value)

    def visit_int(self, expr: EXPR.INT) -> Any:
        node_name = id(expr)
        self.total += f"{node_name} [label=\"INT({expr.value})\"];\n"
from abc import ABC, abstractmethod
from typing import Any, Dict

from ..ast import expression as EXPR
from ..ast import ast as AST


class Visitor(ABC):
    def __init__(self):
        self.forward_dict: Dict[type, Any] = {
            EXPR.INT: self.visit_int,
            EXPR.BinaryArithmetic: self.visit_binary_arithmetic,
            EXPR.BinaryBitwiseArithmetic: self.visit_binary_bitwise_arithmetic,
            EXPR.BinaryLogicalOperation: self.visit_binary_logical_operation,
            EXPR.ComparisonOperation: self.visit_comparison_operation,
            EXPR.UnaryExpression: self.visit_unary_expression,
            EXPR.ShiftExpression: self.visit_shift_expression,
        }

    def visit_ast(self, ast: AST.AST) -> Any:
        ast_type = type(ast)
        handler = self.forward_dict.get(ast_type)
        if handler:
            return handler(ast)
        else:
            raise NotImplementedError(f"No handler found for ast: {ast_type}")

    @abstractmethod
    def visit_binary_arithmetic(self, expr: EXPR.BinaryArithmetic) -> Any:
        pass

    @abstractmethod
    def visit_binary_bitwise_arithmetic(self, expr: EXPR.BinaryBitwiseArithmetic) -> Any:
        pass

    @abstractmethod
    def visit_binary_logical_operation(self, expr: EXPR.BinaryLogicalOperation) -> Any:
        pass

    @abstractmethod
    def visit_comparison_operation(self, expr: EXPR.ComparisonOperation) -> Any:
        pass

    @abstractmethod
    def visit_unary_expression(self, expr: EXPR.UnaryExpression) -> Any:
        pass

    @abstractmethod
    def visit_shift_expression(self, expr: EXPR.ShiftExpression) -> Any:
        pass

    @abstractmethod
    def visit_int(self, expr: EXPR.INT) -> Any:
        pass
